function buildSnakePathBase(cols,rows){const path=[];for(let y=0;y<rows;y++){if(y%2===0){for(let x=0;x<cols;x++)path.push({x,y});}else{for(let x=cols-1;x>=0;x--)path.push({x,y});}}return path;} 
function buildCheckerboardPath(cols, rows) { const path = []; for (let x = 0; x < cols; x += 2) { const left = x; const right = Math.min(x + 1, cols - 1); const stripe = Math.floor(x / 2); if (stripe % 2 === 0) { for (let y = 0; y < rows; y++) { path.push({ x: left, y }); if (right !== left) path.push({ x: right, y }); } } else { for (let y = rows - 1; y >= 0; y--) { path.push({ x: left, y }); if (right !== left) path.push({ x: right, y }); } } } const total = cols * rows; if (path.length !== total) { const base = buildSnakePathBase(cols, rows); for (const p of base) if (!path.some(q => q.x === p.x && q.y === p.y)) path.push(p); } return path; }
function buildCornerSpiralPath(cols, rows) {
  const total = cols * rows; const visited = Array.from({ length: rows }, () => Array(cols).fill(false)); const path = []; let x = 0, y = 0; visited[y][x] = true; path.push({ x, y }); const dirs = [[1,0],[0,1],[-1,0],[0,-1]]; let stepLen = 1; let dirIdx = 0; while (path.length < total) { for (let rep = 0; rep < 2 && path.length < total; rep++) { const [dx, dy] = dirs[dirIdx % 4]; for (let s = 0; s < stepLen && path.length < total; s++) { const nx = x + dx, ny = y + dy; if (nx < 0 || ny < 0 || nx >= cols || ny >= rows || visited[ny][nx]) { let found = false; for (const [fx, fy] of [[1,0],[-1,0],[0,1],[0,-1]]) { const fxn = x + fx, fyn = y + fy; if (fxn >= 0 && fyn >= 0 && fxn < cols && fyn < rows && !visited[fyn][fxn]) { x = fxn; y = fyn; visited[y][x] = true; path.push({ x, y }); found = true; break; } } if (!found) break; } else { x = nx; y = ny; visited[y][x] = true; path.push({ x, y }); } } dirIdx++; } stepLen++; if (path.length < total && path.length === new Set(path.map(p => `${p.x},${p.y}`)).size) break; } if (path.length !== total) { const base = buildSnakePathBase(cols, rows); for (const p of base) if (!path.some(q => q.x === p.x && q.y === p.y)) path.push(p); } return path; }
function buildSpokesPath(cols, rows) { const path = []; const total = cols * rows; const cx = Math.floor((cols - 1) / 2); const colsOrder = []; for (let d = 0; d < cols; d++) { let pos; if (d === 0) pos = cx; else if (d % 2 === 1) pos = cx + Math.ceil(d / 2); else pos = cx - Math.ceil(d / 2); if (pos < 0) pos = 0; if (pos >= cols) pos = cols - 1; if (!colsOrder.includes(pos)) colsOrder.push(pos); } for (let i = 0; i < colsOrder.length; i++) { const col = colsOrder[i]; if (i % 2 === 0) { for (let y = 0; y < rows; y++) path.push({ x: col, y }); } else { for (let y = rows - 1; y >= 0; y--) path.push({ x: col, y }); } } if (path.length !== total) { const base = buildSnakePathBase(cols, rows); for (const p of base) if (!path.some(q => q.x === p.x && q.y === p.y)) path.push(p); } return path; }
console.log('corner 6x6', buildCornerSpiralPath(6,6).length, buildCornerSpiralPath(6,6).slice(0,12));
console.log('corner 5x5', buildCornerSpiralPath(5,5).length, buildCornerSpiralPath(5,5).slice(0,12));
console.log('spokes 6x6', buildSpokesPath(6,6).length, buildSpokesPath(6,6).slice(0,12));
console.log('spokes 5x5', buildSpokesPath(5,5).length, buildSpokesPath(5,5).slice(0,12));