const { writeFileSync } = require('fs');
function buildSnakePathBase(cols,rows){const path=[];for(let y=0;y<rows;y++){if(y%2===0){for(let x=0;x<cols;x++)path.push({x,y});}else{for(let x=cols-1;x>=0;x--)path.push({x,y});}}return path;} 
function buildCheckerboard2x2Path(cols, rows) { const path = []; for (let by = 0; by < rows; by += 2) { const blockRow = Math.floor(by / 2); const blockCols = []; for (let bx = 0; bx < cols; bx += 2) blockCols.push(bx); if (blockRow % 2 === 1) blockCols.reverse(); for (const bx of blockCols) { const xs = [bx, Math.min(bx + 1, cols - 1)]; const ys = [by, Math.min(by + 1, rows - 1)]; if ((bx / 2 + blockRow) % 2 === 0) { for (let y = ys[0]; y <= ys[1]; y++) { for (let x of xs) path.push({ x, y }); } } else { for (let y = ys[1]; y >= ys[0]; y--) { for (let x of xs) path.push({ x, y }); } } } const total = cols * rows; if (path.length !== total) { const base = buildSnakePathBase(cols, rows); for (const p of base) if (!path.some(q => q.x === p.x && q.y === p.y)) path.push(p); } return path; }
function buildDiagonalStripesPath(cols, rows) { const path = []; const maxS = cols + rows - 2; for (let s = 0; s <= maxS; s += 2) { const group = []; for (let k = 0; k < 2 && s + k <= maxS; k++) { const ss = s + k; const diag = []; const xStart = Math.max(0, ss - (rows - 1)); const xEnd = Math.min(cols - 1, ss); for (let x = xStart; x <= xEnd; x++) { const y = ss - x; diag.push({ x, y }); } if ((Math.floor(s / 2) % 2) === 0) diag.reverse(); for (const p of diag) group.push(p); } for (const p of group) path.push(p); } const total = cols * rows; if (path.length !== total) { const base = buildSnakePathBase(cols, rows); for (const p of base) if (!path.some(q => q.x === p.x && q.y === p.y)) path.push(p); } return path; }
function bresenhamLine(x0, y0, x1, y1) { const pts = []; let dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1; let dy = -Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1; let err = dx + dy; while (true) { pts.push({ x: x0, y: y0 }); if (x0 === x1 && y0 === y1) break; const e2 = 2 * err; if (e2 >= dy) { err += dy; x0 += sx; } if (e2 <= dx) { err += dx; y0 += sy; } } return pts; }
function buildTrueSpokesPath(cols, rows) { const cx = (cols - 1) / 2, cy = (rows - 1) / 2; const targets = []; for (let x = 0; x < cols; x++) targets.push({ x, y: 0 }); for (let y = 1; y < rows; y++) targets.push({ x: cols - 1, y }); for (let x = cols - 2; x >= 0; x--) targets.push({ x, y: rows - 1 }); for (let y = rows - 2; y > 0; y--) targets.push({ x: 0, y }); const seen = new Set(); const path = []; for (const t of targets) { const pts = bresenhamLine(Math.round(cx), Math.round(cy), t.x, t.y); for (const p of pts) { const k = `${p.x},${p.y}`; if (!seen.has(k)) { path.push({ x: p.x, y: p.y }); seen.add(k); } } } const total = cols * rows; if (path.length !== total) { const base = buildSnakePathBase(cols, rows); for (const p of base) if (!path.some(q => q.x === p.x && q.y === p.y)) path.push(p); } return path; }
function buildPerimeterFirstPath(cols, rows) { const path = []; const layers = Math.ceil(Math.min(cols, rows) / 2); for (let layer = 0; layer < layers; layer++) { const left = layer, top = layer, right = cols - 1 - layer, bottom = rows - 1 - layer; const ring = []; for (let x = left; x <= right; x++) ring.push({ x, y: top }); for (let y = top + 1; y <= bottom; y++) ring.push({ x: right, y }); if (bottom > top) for (let x = right - 1; x >= left; x--) ring.push({ x, y: bottom }); if (left < right) for (let y = bottom - 1; y > top; y--) ring.push({ x: left, y }); if (!ring.length) continue; if (!path.length) { path.push(...ring); } else { const last = path[path.length - 1]; let idx = ring.findIndex(p => Math.abs(p.x - last.x) + Math.abs(p.y - last.y) === 1); if (idx === -1) { ring.reverse(); idx = ring.findIndex(p => Math.abs(p.x - last.x) + Math.abs(p.y - last.y) === 1); } if (idx !== -1) { const rotated = ring.slice(idx).concat(ring.slice(0, idx)); path.push(...rotated); } else { path.push(...ring); } } } const total = cols * rows; if (path.length !== total) { const base = buildSnakePathBase(cols, rows); for (const p of base) if (!path.some(q => q.x === p.x && q.y === p.y)) path.push(p); } return path; }
function buildHilbertLikePath(cols, rows) { function rec(x0, y0, w, h) { if (w === 1) { const out = []; for (let y = y0; y < y0 + h; y++) out.push({ x: x0, y }); return out; } if (h === 1) { const out = []; for (let x = x0; x < x0 + w; x++) out.push({ x, y: y0 }); return out; } if (w >= h) { const w1 = Math.floor(w / 2), w2 = w - w1; const left = rec(x0, y0, w1, h); const right = rec(x0 + w1, y0, w2, h); const lastL = left[left.length - 1], firstR = right[0]; if (Math.abs(lastL.x - firstR.x) + Math.abs(lastL.y - firstR.y) === 1) return left.concat(right); else return left.concat(right.reverse()); } else { const h1 = Math.floor(h / 2), h2 = h - h1; const top = rec(x0, y0, w, h1); const bottom = rec(x0, y0 + h1, w, h2); const lastT = top[top.length - 1], firstB = bottom[0]; if (Math.abs(lastT.x - firstB.x) + Math.abs(lastT.y - firstB.y) === 1) return top.concat(bottom); else return top.concat(bottom.reverse()); } } const path = rec(0, 0, cols, rows); const total = cols * rows; if (path.length !== total) { const base = buildSnakePathBase(cols, rows); for (const p of base) if (!path.some(q => q.x === p.x && q.y === p.y)) path.push(p); } return path; }
console.log('checker2 6x6', buildCheckerboard2x2Path(6,6).length, buildCheckerboard2x2Path(6,6).slice(0,12));
console.log('diagstripes 6x6', buildDiagonalStripesPath(6,6).length, buildDiagonalStripesPath(6,6).slice(0,12));
console.log('truespokes 6x6', buildTrueSpokesPath(6,6).length, buildTrueSpokesPath(6,6).slice(0,12));
console.log('perimeter 6x6', buildPerimeterFirstPath(6,6).length, buildPerimeterFirstPath(6,6).slice(0,12));
console.log('hilbert 6x6', buildHilbertLikePath(6,6).length, buildHilbertLikePath(6,6).slice(0,12));
writeFileSync('/workspaces/tv-connex/tmp_templates_check2_out.json', JSON.stringify({ c2: buildCheckerboard2x2Path(6,6), ds: buildDiagonalStripesPath(6,6), ts: buildTrueSpokesPath(6,6), pf: buildPerimeterFirstPath(6,6), h: buildHilbertLikePath(6,6) }, null, 2));